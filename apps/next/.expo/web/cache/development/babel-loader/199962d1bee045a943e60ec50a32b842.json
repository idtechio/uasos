{"ast":null,"code":"import { defineAnimation } from \"./util\";\nexport function withDelay(delayMs, _nextAnimation) {\n  'worklet';\n\n  return defineAnimation(_nextAnimation, function () {\n    'worklet';\n\n    var nextAnimation = typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n\n    function delay(animation, now) {\n      var startTime = animation.startTime,\n          started = animation.started,\n          previousAnimation = animation.previousAnimation;\n\n      if (now - startTime > delayMs) {\n        if (!started) {\n          nextAnimation.onStart(nextAnimation, animation.current, now, previousAnimation);\n          animation.previousAnimation = null;\n          animation.started = true;\n        }\n\n        var finished = nextAnimation.onFrame(nextAnimation, now);\n        animation.current = nextAnimation.current;\n        return finished;\n      } else if (previousAnimation) {\n        var _finished = previousAnimation.finished || previousAnimation.onFrame(previousAnimation, now);\n\n        animation.current = previousAnimation.current;\n\n        if (_finished) {\n          animation.previousAnimation = null;\n        }\n      }\n\n      return false;\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      animation.startTime = now;\n      animation.started = false;\n      animation.current = value;\n\n      if (previousAnimation === animation) {\n        animation.previousAnimation = previousAnimation.previousAnimation;\n      } else {\n        animation.previousAnimation = previousAnimation;\n      }\n    }\n\n    var callback = function callback(finished) {\n      if (nextAnimation.callback) {\n        nextAnimation.callback(finished);\n      }\n    };\n\n    return {\n      isHigherOrder: true,\n      onFrame: delay,\n      onStart: onStart,\n      current: nextAnimation.current,\n      callback: callback,\n      previousAnimation: null,\n      startTime: 0,\n      started: false\n    };\n  });\n}\nexport function delay(delayMs, _nextAnimation) {\n  'worklet';\n\n  console.warn('Method `delay` is deprecated. Please use `withDelay` instead');\n  return withDelay(delayMs, _nextAnimation);\n}","map":{"version":3,"sources":["/Users/stanislav.kovalov/Desktop/uasos/node_modules/react-native-reanimated/lib/reanimated2/animation/delay.js"],"names":["defineAnimation","withDelay","delayMs","_nextAnimation","nextAnimation","delay","animation","now","startTime","started","previousAnimation","onStart","current","finished","onFrame","value","callback","isHigherOrder","console","warn"],"mappings":"AAAA,SAASA,eAAT;AACA,OAAO,SAASC,SAAT,CAAmBC,OAAnB,EAA4BC,cAA5B,EAA4C;AAC/C;;AACA,SAAOH,eAAe,CAACG,cAAD,EAAiB,YAAM;AACzC;;AACA,QAAMC,aAAa,GAAG,OAAOD,cAAP,KAA0B,UAA1B,GAAuCA,cAAc,EAArD,GAA0DA,cAAhF;;AACA,aAASE,KAAT,CAAeC,SAAf,EAA0BC,GAA1B,EAA+B;AAC3B,UAAQC,SAAR,GAAkDF,SAAlD,CAAQE,SAAR;AAAA,UAAmBC,OAAnB,GAAkDH,SAAlD,CAAmBG,OAAnB;AAAA,UAA4BC,iBAA5B,GAAkDJ,SAAlD,CAA4BI,iBAA5B;;AACA,UAAIH,GAAG,GAAGC,SAAN,GAAkBN,OAAtB,EAA+B;AAC3B,YAAI,CAACO,OAAL,EAAc;AACVL,UAAAA,aAAa,CAACO,OAAd,CAAsBP,aAAtB,EAAqCE,SAAS,CAACM,OAA/C,EAAwDL,GAAxD,EAA6DG,iBAA7D;AACAJ,UAAAA,SAAS,CAACI,iBAAV,GAA8B,IAA9B;AACAJ,UAAAA,SAAS,CAACG,OAAV,GAAoB,IAApB;AACH;;AACD,YAAMI,QAAQ,GAAGT,aAAa,CAACU,OAAd,CAAsBV,aAAtB,EAAqCG,GAArC,CAAjB;AACAD,QAAAA,SAAS,CAACM,OAAV,GAAoBR,aAAa,CAACQ,OAAlC;AACA,eAAOC,QAAP;AACH,OATD,MAUK,IAAIH,iBAAJ,EAAuB;AACxB,YAAMG,SAAQ,GAAGH,iBAAiB,CAACG,QAAlB,IACbH,iBAAiB,CAACI,OAAlB,CAA0BJ,iBAA1B,EAA6CH,GAA7C,CADJ;;AAEAD,QAAAA,SAAS,CAACM,OAAV,GAAoBF,iBAAiB,CAACE,OAAtC;;AACA,YAAIC,SAAJ,EAAc;AACVP,UAAAA,SAAS,CAACI,iBAAV,GAA8B,IAA9B;AACH;AACJ;;AACD,aAAO,KAAP;AACH;;AACD,aAASC,OAAT,CAAiBL,SAAjB,EAA4BS,KAA5B,EAAmCR,GAAnC,EAAwCG,iBAAxC,EAA2D;AACvDJ,MAAAA,SAAS,CAACE,SAAV,GAAsBD,GAAtB;AACAD,MAAAA,SAAS,CAACG,OAAV,GAAoB,KAApB;AACAH,MAAAA,SAAS,CAACM,OAAV,GAAoBG,KAApB;;AACA,UAAIL,iBAAiB,KAAKJ,SAA1B,EAAqC;AACjCA,QAAAA,SAAS,CAACI,iBAAV,GAA8BA,iBAAiB,CAACA,iBAAhD;AACH,OAFD,MAGK;AACDJ,QAAAA,SAAS,CAACI,iBAAV,GAA8BA,iBAA9B;AACH;AACJ;;AACD,QAAMM,QAAQ,GAAG,SAAXA,QAAW,CAACH,QAAD,EAAc;AAC3B,UAAIT,aAAa,CAACY,QAAlB,EAA4B;AACxBZ,QAAAA,aAAa,CAACY,QAAd,CAAuBH,QAAvB;AACH;AACJ,KAJD;;AAKA,WAAO;AACHI,MAAAA,aAAa,EAAE,IADZ;AAEHH,MAAAA,OAAO,EAAET,KAFN;AAGHM,MAAAA,OAAO,EAAPA,OAHG;AAIHC,MAAAA,OAAO,EAAER,aAAa,CAACQ,OAJpB;AAKHI,MAAAA,QAAQ,EAARA,QALG;AAMHN,MAAAA,iBAAiB,EAAE,IANhB;AAOHF,MAAAA,SAAS,EAAE,CAPR;AAQHC,MAAAA,OAAO,EAAE;AARN,KAAP;AAUH,GAnDqB,CAAtB;AAoDH;AAID,OAAO,SAASJ,KAAT,CAAeH,OAAf,EAAwBC,cAAxB,EAAwC;AAC3C;;AACAe,EAAAA,OAAO,CAACC,IAAR,CAAa,8DAAb;AACA,SAAOlB,SAAS,CAACC,OAAD,EAAUC,cAAV,CAAhB;AACH","sourcesContent":["import { defineAnimation } from './util';\nexport function withDelay(delayMs, _nextAnimation) {\n    'worklet';\n    return defineAnimation(_nextAnimation, () => {\n        'worklet';\n        const nextAnimation = typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n        function delay(animation, now) {\n            const { startTime, started, previousAnimation } = animation;\n            if (now - startTime > delayMs) {\n                if (!started) {\n                    nextAnimation.onStart(nextAnimation, animation.current, now, previousAnimation);\n                    animation.previousAnimation = null;\n                    animation.started = true;\n                }\n                const finished = nextAnimation.onFrame(nextAnimation, now);\n                animation.current = nextAnimation.current;\n                return finished;\n            }\n            else if (previousAnimation) {\n                const finished = previousAnimation.finished ||\n                    previousAnimation.onFrame(previousAnimation, now);\n                animation.current = previousAnimation.current;\n                if (finished) {\n                    animation.previousAnimation = null;\n                }\n            }\n            return false;\n        }\n        function onStart(animation, value, now, previousAnimation) {\n            animation.startTime = now;\n            animation.started = false;\n            animation.current = value;\n            if (previousAnimation === animation) {\n                animation.previousAnimation = previousAnimation.previousAnimation;\n            }\n            else {\n                animation.previousAnimation = previousAnimation;\n            }\n        }\n        const callback = (finished) => {\n            if (nextAnimation.callback) {\n                nextAnimation.callback(finished);\n            }\n        };\n        return {\n            isHigherOrder: true,\n            onFrame: delay,\n            onStart,\n            current: nextAnimation.current,\n            callback,\n            previousAnimation: null,\n            startTime: 0,\n            started: false,\n        };\n    });\n}\n/**\n * @deprecated Kept for backward compatibility. Will be removed soon.\n */\nexport function delay(delayMs, _nextAnimation) {\n    'worklet';\n    console.warn('Method `delay` is deprecated. Please use `withDelay` instead');\n    return withDelay(delayMs, _nextAnimation);\n}\n"]},"metadata":{},"sourceType":"module"}