"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MotiProgressBar = MotiProgressBar;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _core = require("@motify/core");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const MotiView = (0, _core.motify)(_reactNative.View)();

function MotiProgressBar({
  height = 12,
  progress = 0,
  borderRadius = height / 2,
  style,
  colorMode = 'dark',
  containerColor = colorMode === 'dark' ? '#333' : '#eee',
  containerStyle,
  color = '#00C806',
  transition = {
    type: 'timing',
    duration: 200
  },
  silenceRenderWarnings = false
}) {
  const barState = (0, _core.useDynamicAnimation)(() => ({
    translateX: '-100%'
  })); // TODO this won't be necessary once Moti memoizes props for you.

  if (!transition) {
    console.error("[moti] <ProgressBar /> \"transition\" prop must be undefined or a Moti transition object, but it got this type instead: ".concat(typeof transition, "."), transition);
  }

  const transitionString = JSON.stringify(transition);

  const _transition = (0, _react.useMemo)(() => JSON.parse(transitionString), [transitionString]);

  const outerStyle = (0, _react.useMemo)(() => [styles.container, containerStyle, {
    height,
    borderRadius,
    backgroundColor: containerColor
  }], [borderRadius, containerColor, containerStyle, height]);
  const progressStyle = (0, _react.useMemo)(() => [style, styles.bar, {
    borderRadius,
    backgroundColor: color
  }], [borderRadius, color, style]);
  (0, _react.useEffect)(function animateOnProgressChange() {
    var _barState$current;

    const percent = Math.round(progress * 100);
    const translateX = "".concat(percent - 100, "%");

    if (((_barState$current = barState.current) === null || _barState$current === void 0 ? void 0 : _barState$current.translateX) !== translateX) {
      barState.animateTo(current => ({ ...current,
        translateX
      }));
    }
  }, [barState, progress]);
  const unnecessaryRerenders = (0, _react.useRef)({
    containerStyle: {
      previousValue: containerStyle,
      changes: 0
    },
    style: {
      previousValue: style,
      changes: 0
    }
  });
  (0, _react.useEffect)(function checkUnnecessaryRerenders() {
    const isDev = typeof __DEV__ === 'undefined' || __DEV__;

    if (silenceRenderWarnings || !isDev) {
      return;
    }

    if (containerStyle !== unnecessaryRerenders.current.containerStyle.previousValue) {
      unnecessaryRerenders.current.containerStyle.changes += 1;
    }

    if (style !== unnecessaryRerenders.current.style.previousValue) {
      unnecessaryRerenders.current.style.changes += 1;
    }

    const warningProps = [];
    Object.entries(unnecessaryRerenders.current).forEach(([prop, {
      changes
    }]) => {
      if (changes > 5) {
        warningProps.push({
          prop,
          changes
        });
      }
    });

    if (warningProps.length) {
      console.warn("[moti] <MotiProgress /> is re-rendering often due to these props: ".concat(warningProps.map(warning => "\"".concat(warning.prop, ": ").concat(warning.changes, " re-renders\"")).join(', '), ". This can reduce animation performance. Please memoize these props with useMemo, or create them outside of render code."), "If you are intentionally re-rendering this often, for some reason, pass silenceRenderWarnings={true} on this component.");
    }
  }, [containerStyle, silenceRenderWarnings, style]);
  return (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: outerStyle
  }, /*#__PURE__*/_react.default.createElement(MotiView, {
    transition: _transition,
    state: barState,
    style: progressStyle
  })), [_transition, barState, outerStyle, progressStyle]);
}

const styles = _reactNative.StyleSheet.create({
  container: {
    width: '100%',
    overflow: 'hidden'
  },
  bar: {
    width: '100%',
    height: '100%'
  }
});
//# sourceMappingURL=index.js.map