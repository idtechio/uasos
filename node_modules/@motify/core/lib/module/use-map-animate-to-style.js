import { PresenceContext, usePresence } from 'framer-motion';
import { useCallback, useContext, useEffect } from 'react';
import { useAnimatedStyle, useSharedValue, withDecay, withSpring, withTiming, withDelay, withRepeat, withSequence, runOnJS } from 'react-native-reanimated';
import { PackageName } from './constants/package-name';

const debug = (...args) => {
  'worklet';

  if (args) {// hi
  } // console.log('[moti]', ...args)

};

const isColor = styleKey => {
  'worklet';

  const keys = {
    backgroundColor: true,
    borderBottomColor: true,
    borderLeftColor: true,
    borderRightColor: true,
    borderTopColor: true,
    color: true,
    shadowColor: true,
    borderColor: true,
    borderEndColor: true,
    borderStartColor: true
  };
  return Boolean(keys[styleKey]);
};

const isTransform = styleKey => {
  'worklet';

  const transforms = {
    perspective: true,
    rotate: true,
    rotateX: true,
    rotateY: true,
    rotateZ: true,
    scale: true,
    scaleX: true,
    scaleY: true,
    translateX: true,
    translateY: true,
    skewX: true,
    skewY: true
  };
  return Boolean(transforms[styleKey]);
};

function animationDelay(_key, transition, defaultDelay) {
  'worklet';

  var _transition$key;

  const key = _key;
  let delayMs = defaultDelay;

  if ((transition === null || transition === void 0 ? void 0 : (_transition$key = transition[key]) === null || _transition$key === void 0 ? void 0 : _transition$key.delay) != null) {
    var _transition$key2;

    delayMs = transition === null || transition === void 0 ? void 0 : (_transition$key2 = transition[key]) === null || _transition$key2 === void 0 ? void 0 : _transition$key2.delay;
  } else if ((transition === null || transition === void 0 ? void 0 : transition.delay) != null) {
    delayMs = transition.delay;
  }

  return {
    delayMs
  };
}

function animationConfig(styleProp, transition) {
  'worklet';

  var _styleSpecificTransit;

  const key = styleProp;
  let repeatCount = 0;
  let repeatReverse = true;
  let animationType = 'spring';
  if (isColor(key) || key === 'opacity') animationType = 'timing';
  const styleSpecificTransition = transition === null || transition === void 0 ? void 0 : transition[key]; // say that we're looking at `width`
  // first, check if we have transition.width.type

  if (styleSpecificTransition !== null && styleSpecificTransition !== void 0 && styleSpecificTransition.type) {
    animationType = styleSpecificTransition.type;
  } else if (transition !== null && transition !== void 0 && transition.type) {
    // otherwise, fallback to transition.type
    animationType = transition.type;
  }

  const loop = (_styleSpecificTransit = styleSpecificTransition === null || styleSpecificTransition === void 0 ? void 0 : styleSpecificTransition.loop) !== null && _styleSpecificTransit !== void 0 ? _styleSpecificTransit : transition === null || transition === void 0 ? void 0 : transition.loop;

  if (loop != null) {
    repeatCount = loop ? -1 : 0;
  }

  if ((styleSpecificTransition === null || styleSpecificTransition === void 0 ? void 0 : styleSpecificTransition.repeat) != null) {
    repeatCount = styleSpecificTransition === null || styleSpecificTransition === void 0 ? void 0 : styleSpecificTransition.repeat;
  } else if ((transition === null || transition === void 0 ? void 0 : transition.repeat) != null) {
    repeatCount = transition.repeat;
  }

  if ((styleSpecificTransition === null || styleSpecificTransition === void 0 ? void 0 : styleSpecificTransition.repeatReverse) != null) {
    repeatReverse = styleSpecificTransition.repeatReverse;
  } else if ((transition === null || transition === void 0 ? void 0 : transition.repeatReverse) != null) {
    repeatReverse = transition.repeatReverse;
  }

  debug({
    loop,
    key,
    repeatCount,
    animationType
  });
  let config = {}; // so sad, but fix it later :(

  let animation = (...props) => props;

  if (animationType === 'timing') {
    var _duration, _transition$key3, _easing, _transition$key4;

    const duration = (_duration = transition === null || transition === void 0 ? void 0 : (_transition$key3 = transition[key]) === null || _transition$key3 === void 0 ? void 0 : _transition$key3.duration) !== null && _duration !== void 0 ? _duration : transition === null || transition === void 0 ? void 0 : transition.duration;
    const easing = (_easing = transition === null || transition === void 0 ? void 0 : (_transition$key4 = transition[key]) === null || _transition$key4 === void 0 ? void 0 : _transition$key4.easing) !== null && _easing !== void 0 ? _easing : transition === null || transition === void 0 ? void 0 : transition.easing;

    if (easing) {
      config['easing'] = easing;
    }

    if (duration != null) {
      config['duration'] = duration;
    }

    animation = withTiming;
  } else if (animationType === 'spring') {
    animation = withSpring;
    config = {};
    const configKeys = ['damping', 'mass', 'overshootClamping', 'restDisplacementThreshold', 'restSpeedThreshold', 'stiffness', 'velocity'];

    for (const configKey of configKeys) {
      var _transition$key5;

      const styleSpecificConfig = transition === null || transition === void 0 ? void 0 : (_transition$key5 = transition[key]) === null || _transition$key5 === void 0 ? void 0 : _transition$key5[configKey];
      const transitionConfigForKey = transition === null || transition === void 0 ? void 0 : transition[configKey];

      if (styleSpecificConfig != null) {
        config[configKey] = styleSpecificConfig;
      } else if (transitionConfigForKey != null) {
        config[configKey] = transitionConfigForKey;
      }
    }
  } else if (animationType === 'decay') {
    animation = withDecay;
    config = {
      velocity: 2,
      deceleration: 2
    };
    const configKeys = ['clamp', 'velocity', 'deceleration', 'velocityFactor'];

    for (const configKey of configKeys) {
      var _transition$key6;

      // is this necessary ^ don't think so...?
      const styleSpecificConfig = transition === null || transition === void 0 ? void 0 : (_transition$key6 = transition[key]) === null || _transition$key6 === void 0 ? void 0 : _transition$key6[configKey];
      const transitionConfigForKey = transition === null || transition === void 0 ? void 0 : transition[configKey];

      if (styleSpecificConfig != null) {
        config[configKey] = styleSpecificConfig;
      } else if (transitionConfigForKey != null) {
        config[configKey] = transitionConfigForKey;
      }
    }
  }

  return {
    animation,
    config,
    repeatReverse,
    repeatCount,
    shouldRepeat: !!repeatCount
  };
}

export function useMotify({
  animate: animateProp,
  from: fromProp = false,
  transition: transitionProp,
  exitTransition: exitTransitionProp,
  delay: defaultDelay,
  state,
  stylePriority = 'animate',
  onDidAnimate,
  exit: exitProp,
  animateInitialState = false
}) {
  const isMounted = useSharedValue(false);
  const [isPresent, safeToUnmount] = usePresence();
  const presence = useContext(PresenceContext);
  const disableInitialAnimation = (presence === null || presence === void 0 ? void 0 : presence.initial) === false && !animateInitialState;
  const custom = useCallback(() => {
    'worklet';

    return presence === null || presence === void 0 ? void 0 : presence.custom;
  }, [presence]);
  const reanimatedSafeToUnmount = useCallback(() => {
    safeToUnmount === null || safeToUnmount === void 0 ? void 0 : safeToUnmount();
  }, [safeToUnmount]);
  const reanimatedOnDidAnimated = useCallback((...args) => {
    onDidAnimate === null || onDidAnimate === void 0 ? void 0 : onDidAnimate(...args);
  }, [onDidAnimate]);
  const hasExitStyle = Boolean(typeof exitProp === 'function' || typeof exitProp === 'object' && exitProp && Object.keys(exitProp).length > 0);
  const style = useAnimatedStyle(() => {
    var _state$__state, _final$transform;

    const final = {
      // initializing here fixes reanimated object.__defineProperty bug(?)
      transform: []
    };
    const variantStyle = (state === null || state === void 0 ? void 0 : (_state$__state = state.__state) === null || _state$__state === void 0 ? void 0 : _state$__state.value) || {};
    let animateStyle;

    if (animateProp && 'value' in animateProp) {
      animateStyle = animateProp.value || {};
    } else {
      animateStyle = animateProp || {};
    }

    const initialStyle = fromProp || {};
    let exitStyle = exitProp || {};

    if (typeof exitStyle === 'function') {
      exitStyle = exitStyle(custom());
    }

    const isExiting = !isPresent && hasExitStyle;
    let mergedStyles = {};

    if (stylePriority === 'state') {
      mergedStyles = Object.assign({}, animateStyle, variantStyle);
    } else {
      mergedStyles = Object.assign({}, variantStyle, animateStyle);
    }

    if (!isMounted.value && !disableInitialAnimation && Object.keys(initialStyle).length) {
      mergedStyles = initialStyle;
    } else {
      mergedStyles = Object.assign({}, initialStyle, mergedStyles);
    }

    if (isExiting && exitStyle) {
      mergedStyles = Object.assign({}, exitStyle);
    }

    const exitingStyleProps = {};

    for (const key in exitStyle || {}) {
      exitingStyleProps[key] = true;
    } // allow shared values as transitions


    let transition;

    if (transitionProp && 'value' in transitionProp) {
      transition = transitionProp.value;
    } else {
      transition = transitionProp;
    }

    if (isExiting && exitTransitionProp) {
      let exitTransition;

      if (exitTransitionProp && 'value' in exitTransitionProp) {
        exitTransition = exitTransitionProp.value;
      } else {
        exitTransition = exitTransitionProp;
      }

      transition = Object.assign({}, transition, exitTransition);
    }

    for (const _key in mergedStyles) {
      const key = _key;
      const value = mergedStyles[key];
      const {
        animation,
        config,
        shouldRepeat,
        repeatCount,
        repeatReverse
      } = animationConfig(key, transition);

      const callback = (completed, recentValue) => {
        if (onDidAnimate) {
          runOnJS(reanimatedOnDidAnimated)(key, completed, recentValue, {
            attemptedValue: value
          });
        }

        if (isExiting) {
          exitingStyleProps[key] = false;
          const areStylesExiting = Object.values(exitingStyleProps).some(Boolean); // if this is true, then we've finished our exit animations

          if (!areStylesExiting) {
            runOnJS(reanimatedSafeToUnmount)();
          }
        }
      };

      let {
        delayMs
      } = animationDelay(key, transition, defaultDelay);

      if (value == null || value === false) {
        // skip missing values
        // this is useful if you want to do {opacity: loading && 1}
        // without this, those values will break I think
        continue;
      }

      const getSequenceArray = (sequenceKey, sequenceArray) => {
        const sequence = [];

        for (const step of sequenceArray) {
          const shouldPush = typeof step === 'object' ? step && (step === null || step === void 0 ? void 0 : step.value) != null && (step === null || step === void 0 ? void 0 : step.value) !== false : step != null && step !== false;

          if (shouldPush) {
            let stepDelay = delayMs;
            let stepValue = step;
            let stepConfig = Object.assign({}, config);
            let stepAnimation = animation;

            if (typeof step === 'object') {
              // not allowed in Reanimated: { delay, value, ...transition } = step
              const stepTransition = Object.assign({}, step);
              delete stepTransition.delay;
              delete stepTransition.value;
              const {
                config: inlineStepConfig,
                animation
              } = animationConfig(sequenceKey, stepTransition);
              stepConfig = Object.assign({}, stepConfig, inlineStepConfig);
              stepAnimation = animation;

              if (step.delay != null) {
                stepDelay = step.delay;
              }

              stepValue = step.value;
            }

            const sequenceValue = stepAnimation(stepValue, stepConfig, callback);

            if (stepDelay != null) {
              sequence.push(withDelay(stepDelay, sequenceValue));
            } else {
              sequence.push(sequenceValue);
            }
          }
        }

        return sequence;
      };

      if (key === 'transform') {
        if (!Array.isArray(value)) {
          console.error("[".concat(PackageName, "]: Invalid transform value. Needs to be an array."));
        } else {
          for (const transformObject of value) {
            final['transform'] = final['transform'] || [];
            const transformKey = Object.keys(transformObject)[0];
            const transformValue = transformObject[transformKey];
            const transform = {};

            if (Array.isArray(transformValue)) {
              // we have a sequence in this transform...
              const sequence = getSequenceArray(transformKey, transformValue);

              if (sequence.length) {
                let finalValue = withSequence(sequence[0], ...sequence.slice(1));

                if (shouldRepeat) {
                  finalValue = withRepeat(finalValue, repeatCount, repeatReverse);
                }

                transform[transformKey] = finalValue;
              }
            } else {
              var _transition, _transition$transform;

              if (((_transition = transition) === null || _transition === void 0 ? void 0 : (_transition$transform = _transition[transformKey]) === null || _transition$transform === void 0 ? void 0 : _transition$transform.delay) != null) {
                var _transition2, _transition2$transfor;

                delayMs = (_transition2 = transition) === null || _transition2 === void 0 ? void 0 : (_transition2$transfor = _transition2[transformKey]) === null || _transition2$transfor === void 0 ? void 0 : _transition2$transfor.delay;
              }

              let finalValue = animation(transformValue, config, callback);

              if (shouldRepeat) {
                finalValue = withRepeat(finalValue, repeatCount, repeatReverse);
              }

              if (delayMs != null) {
                transform[transformKey] = withDelay(delayMs, finalValue);
              } else {
                transform[transformKey] = finalValue;
              }
            }

            if (Object.keys(transform).length) {
              final['transform'].push(transform);
            }
          }
        }
      } else if (Array.isArray(value)) {
        // we have a sequence
        const sequence = getSequenceArray(key, value);
        let finalValue = withSequence(sequence[0], ...sequence.slice(1));

        if (shouldRepeat) {
          finalValue = withRepeat(finalValue, repeatCount, repeatReverse);
        }

        if (isTransform(key)) {
          // we have a sequence of transforms
          final['transform'] = final['transform'] || [];

          if (sequence.length) {
            const transform = {};
            transform[key] = finalValue; // @ts-expect-error transform had the wrong type

            final['transform'].push(transform);
          }
        } else {
          // we have a normal sequence of items
          // shadows not supported
          if (sequence.length) {
            final[key] = finalValue;
          }
        }
      } else if (isTransform(key)) {
        var _transition3, _transition3$key;

        final['transform'] = final['transform'] || []; // const transformKey = Object.keys(transformProp)[0]
        // const transformValue = transformProp[transformKey]

        if (((_transition3 = transition) === null || _transition3 === void 0 ? void 0 : (_transition3$key = _transition3[key]) === null || _transition3$key === void 0 ? void 0 : _transition3$key.delay) != null) {
          var _transition4, _transition4$key;

          delayMs = (_transition4 = transition) === null || _transition4 === void 0 ? void 0 : (_transition4$key = _transition4[key]) === null || _transition4$key === void 0 ? void 0 : _transition4$key.delay;
        }

        const transform = {};
        let finalValue = animation(value, config, callback);

        if (shouldRepeat) {
          finalValue = withRepeat(finalValue, repeatCount, repeatReverse);
        }

        if (delayMs != null) {
          transform[key] = withDelay(delayMs, finalValue);
        } else {
          transform[key] = finalValue;
        } // @ts-expect-error transform had the wrong type


        final['transform'].push(transform);
      } else if (typeof value === 'object') {
        // shadows
        final[key] = {};

        for (const innerStyleKey in value || {}) {
          let finalValue = animation(value, config, callback);

          if (shouldRepeat) {
            finalValue = withRepeat(finalValue, repeatCount, repeatReverse);
          }

          if (delayMs != null) {
            final[key][innerStyleKey] = withDelay(delayMs, finalValue);
          } else {
            final[key][innerStyleKey] = finalValue;
          }
        }
      } else {
        let finalValue = animation(value, config, callback);

        if (shouldRepeat) {
          finalValue = withRepeat(finalValue, repeatCount, repeatReverse);
        }

        if (delayMs != null && typeof delayMs === 'number') {
          final[key] = withDelay(delayMs, finalValue);
        } else {
          final[key] = finalValue;
        }
      }
    }

    if (!((_final$transform = final.transform) !== null && _final$transform !== void 0 && _final$transform.length)) {
      delete final.transform;
    }

    return final;
  }, [animateProp, custom, defaultDelay, disableInitialAnimation, exitProp, exitTransitionProp, fromProp, hasExitStyle, isMounted, isPresent, onDidAnimate, reanimatedOnDidAnimated, reanimatedSafeToUnmount, state, stylePriority, transitionProp]);
  useEffect(() => {
    isMounted.value = true;
  }, [isMounted]);
  useEffect(function allowUnMountIfMissingExit() {
    if (!isPresent && !hasExitStyle) {
      reanimatedSafeToUnmount();
    }
  }, [hasExitStyle, isPresent, reanimatedSafeToUnmount]);
  return {
    style
  };
}
//# sourceMappingURL=use-map-animate-to-style.js.map