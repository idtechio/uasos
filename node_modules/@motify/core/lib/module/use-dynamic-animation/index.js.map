{"version":3,"sources":["index.ts"],"names":["useSharedValue","useRef","fallback","useDynamicAnimation","initialState","activeStyle","value","current","__state","controller","animateTo","nextStateOrFunction","nextStyle"],"mappings":"AACA,SAASA,cAAT,QAA+B,yBAA/B;AACA,SAASC,MAAT,QAAuB,OAAvB;;AAIA,MAAMC,QAAQ,GAAG,OAAO,EAAP,CAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAe,SAASC,mBAAT,CACbC,YAA0B,GAAGF,QADhB,EAEb;AACA,QAAMG,WAAW,GAAGJ,MAAM,CAA8B;AACtDK,IAAAA,KAAK,EAAE;AAD+C,GAA9B,CAA1B;;AAGA,MAAID,WAAW,CAACE,OAAZ,CAAoBD,KAApB,KAA8B,IAAlC,EAAwC;AACtC;AACAD,IAAAA,WAAW,CAACE,OAAZ,CAAoBD,KAApB,GAA4BF,YAAY,EAAxC;AACD;;AAED,QAAMI,OAAO,GAAGR,cAAc,CAACK,WAAW,CAACE,OAAZ,CAAoBD,KAArB,CAA9B;;AAEA,QAAMG,UAAU,GAAGR,MAAM,EAAzB;;AAEA,MAAIQ,UAAU,CAACF,OAAX,IAAsB,IAA1B,EAAgC;AAC9BE,IAAAA,UAAU,CAACF,OAAX,GAAqB;AACnBC,MAAAA,OADmB;;AAEnB,UAAID,OAAJ,GAAgC;AAC9B,eAAOC,OAAO,CAACF,KAAf;AACD,OAJkB;;AAKnBI,MAAAA,SAAS,CAACC,mBAAD,EAAsB;AAC7B;;AAEA,cAAMC,SAAS,GACb,OAAOD,mBAAP,KAA+B,UAA/B,GACIA,mBAAmB,CAACH,OAAO,CAACF,KAAT,CADvB,GAEIK,mBAHN;AAKAH,QAAAA,OAAO,CAACF,KAAR,GAAgBM,SAAhB;AACD;;AAdkB,KAArB;AAgBD;;AAED,SAAOH,UAAU,CAACF,OAAlB;AACD","sourcesContent":["import type { DynamicStyleProp, UseDynamicAnimationState } from './../types'\nimport { useSharedValue } from 'react-native-reanimated'\nimport { useRef } from 'react'\n\ntype InitialState = () => DynamicStyleProp\n\nconst fallback = () => ({})\n\n/**\n * A hook that acts like `useAnimationState`, except that it allows for dynamic values rather than static variants.\n *\n * This is useful when you want to update styles on the fly the way you do with `useState`.\n *\n * You can change the state by calling `state.animateTo()`, and access the current state by calling `state.current`.\n *\n * This hook has high performance, triggers no state changes, and runs fully on the native thread!\n *\n * ```js\n * const dynamicAnimation = useDynamicAnimation({ opacity: 0 })\n *\n * const onPress = () => {\n *   dynamicAnimation.animateTo({ opacity: 1 })\n * }\n *\n * const onMergeStyle = () => {\n *   // or, merge your styles\n *   // this uses the previous state, like useState from react\n *   dynamicAnimation.animateTo((current) => ({ ...current, scale: 1 }))\n *\n *   // you can also synchronously read the current value\n *   // these two options are the same!\n *   dynamicAnimation.animateTo({ ...dynamicAnimation.current, scale: 1 })\n * }\n * ```\n *\n * @param initialState A function that returns your initial style. Similar to `useState`'s initial style.\n */\nexport default function useDynamicAnimation(\n  initialState: InitialState = fallback\n) {\n  const activeStyle = useRef<{ value: DynamicStyleProp }>({\n    value: null as any,\n  })\n  if (activeStyle.current.value === null) {\n    // use a .value to be certain it's never been set\n    activeStyle.current.value = initialState()\n  }\n\n  const __state = useSharedValue(activeStyle.current.value)\n\n  const controller = useRef<UseDynamicAnimationState>()\n\n  if (controller.current == null) {\n    controller.current = {\n      __state,\n      get current(): DynamicStyleProp {\n        return __state.value\n      },\n      animateTo(nextStateOrFunction) {\n        'worklet'\n\n        const nextStyle =\n          typeof nextStateOrFunction === 'function'\n            ? nextStateOrFunction(__state.value)\n            : nextStateOrFunction\n\n        __state.value = nextStyle\n      },\n    }\n  }\n\n  return controller.current as UseDynamicAnimationState\n}\n"]}