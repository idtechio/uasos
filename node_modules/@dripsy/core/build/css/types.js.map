{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/css/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { ThemeUICSSProperties } from '@theme-ui/css'\nimport type { ComponentType } from 'react'\nimport type { ViewStyle, TextStyle, ImageStyle } from 'react-native'\nimport type { TextShadows } from '../declarations'\nimport type { DripsyThemeWithoutIgnoredKeys } from '../declarations'\nimport type { Shadows } from '../declarations'\nimport type { DripsyFinalTheme } from '../declarations'\nimport type { Aliases, Scales } from './scales'\n\nexport type DefaultStyleKey = 'defaultStyle'\n\nexport type ThemedOptions<\n  ExtraProps,\n  ThemeKey extends Extract<keyof DripsyFinalTheme, string>\n> = {\n  [key in DefaultStyleKey]?: Sx | ((props: ExtraProps) => Sx)\n} & {\n  defaultVariant?: (string & {}) | DripsyVariant<ThemeKey>\n  /**\n   * List of multiple variants\n   */\n  defaultVariants?: ((string & {}) | DripsyVariant<ThemeKey>)[]\n  themeKey?: ThemeKey\n}\n\n// https://github.com/intergalacticspacehighway/react-native-styled-variants/blob/main/src/types.ts\n// thank you @nishanbende!\ntype HiddenArrayKeys = Exclude<keyof [], number>\n\ntype SafeTokenized<\n  Theme,\n  IsFirstIteration extends boolean,\n  Key extends Extract<keyof Theme, string | number>,\n  AllowsRootKeys extends boolean\n> = IsFirstIteration extends true\n  ? AllowsRootKeys extends false // exclude the first key from the options\n    ? // for example: { colors: { primary: { 100: '' } } } would result in 'primary' or 'primary.100'\n      Tokenize<Theme[Key], false, false>\n    :\n        | Tokenize<Theme[Key], false, false>\n        | `${Key}.${Tokenize<Theme[Key], false, false>}`\n  : // we're not on the first iteration, so we can return colors or colors.${keyof colors}\n    // this was created as a generic to make it only once\n    `${Key}.${Tokenize<Theme[Key], IsFirstIteration>}`\n\n// TODO replace with this maybe? https://github.com/system-ui/theme-ui/pull/1090/files#diff-7ef5a8c1a0ef5be9914c14678b6cf85955e354f070f14769ab856c495d3879a4R22\ntype Tokenize<\n  Theme,\n  IsFirstIteration extends boolean,\n  AllowsRootKeys extends boolean = true\n> = Extract<\n  keyof {\n    [Key in Exclude<\n      Extract<keyof Theme, string | number>,\n      HiddenArrayKeys\n    > as Theme[Key] extends string | number | '' | never | undefined | null\n      ? Key extends number\n        ? Key\n        : `${Key}`\n      : // if we're iterating over the key of the theme\n        // for example, if key = 'colors'\n        // and colors: { primary: '...' }\n        // then we should allow either colors.primary, OR colors\n        // to toggle that, just set the last argument to true/false\n        // `${Key}.${Tokenize<Theme[Key]>}`\n        | `${Key}` // here, we have an object, say layout.wide. We want both layout.wide and layout.wide.width\n          // so we include key, *or* tokenized theme for this key\n          | SafeTokenized<Theme, IsFirstIteration, Key, AllowsRootKeys>]: true\n  },\n  string | number | '' | never | undefined | null\n>\n\n// we shouldn't be putting keys\ntype TokenizedTheme<AllowsRootKey extends boolean = false> = Tokenize<\n  DripsyThemeWithoutIgnoredKeys,\n  true,\n  AllowsRootKey\n>\n\ntype ScaleValue = Scales[keyof Scales]\n\n// turn p -> padding (see alias variable)\ntype AliasToScale<\n  ScaleOrAlias extends\n    | keyof DripsyThemeWithoutIgnoredKeys\n    | keyof ThemeUICSSProperties\n> = ScaleOrAlias extends keyof Aliases\n  ? Aliases[ScaleOrAlias] extends keyof Scales\n    ? Scales[Aliases[ScaleOrAlias]] extends keyof DripsyThemeWithoutIgnoredKeys\n      ? Scales[Aliases[ScaleOrAlias]]\n      : ScaleOrAlias\n    : ScaleOrAlias\n  : ScaleOrAlias\n\nexport type MaybeTokenizedValue<\n  Key extends keyof ThemeUICSSProperties,\n  Scale extends\n    | keyof DripsyThemeWithoutIgnoredKeys\n    | keyof ThemeUICSSProperties = Key extends keyof Scales\n    ? // if Key = 'color'\n      // then Scales['color'] = 'colors'\n      // so if 'colors' is a keyof the theme\n      // then the scale is indeed 'colors', and we tokenize theme.colors\n      Scales[Key] extends keyof DripsyThemeWithoutIgnoredKeys\n      ? Scales[Key]\n      : Key\n    : Key,\n  AliasedScale extends Scale = AliasToScale<Scale>\n> = AliasedScale extends ScaleValue\n  ? // the scale we chose points to a potential theme value\n    // the scale points to a theme value which is indeed in our custom theme\n    // so we tokenize the options at theme[scale]\n    // example:\n    // Key = 'color'\n    // scales[color] = 'colors'\n    // if theme.colors exists, then we tokenize theme[colors]\n    Tokenize<DripsyThemeWithoutIgnoredKeys[AliasedScale], true, false>\n  : TokenizedTheme\n\nexport type ResponsiveValue<T> = T | (null | T)[] | null | undefined\n// Some properties are in React Native only and don't exist on the theme-ui spec\n// so we add them here\n\n// first create a getter for a given property name\n// in this case, we want `<textShadow|boxShadow>` to let you pick a `theme.<textShadows|shadows>` option\ntype CssPropertyNames = {\n  [key in keyof ThemeUICSSProperties]: key\n}\ntype SpecialCssProperty<Key extends keyof CssPropertyNames> = NonNullable<\n  CssPropertyNames[Key]\n>\ntype BoxShadow = SpecialCssProperty<'boxShadow'>\ntype TextShadow = SpecialCssProperty<'textShadow'>\n\ntype MakeShadowStyle<\n  Key extends keyof ThemeUICSSProperties,\n  Property extends keyof DripsyFinalTheme\n> = ResponsiveValue<\n  (ThemeUICSSProperties[Key] & {}) | keyof DripsyFinalTheme[Property]\n>\n\nexport type WebShadowStyles = {\n  [key in BoxShadow]?: MakeShadowStyle<key, 'shadows'>\n} &\n  {\n    [key in TextShadow]?: MakeShadowStyle<key, 'textShadows'>\n  }\n\nexport type ShadowStyleKeys = keyof WebShadowStyles\n\nexport type StyleableSxProperties = Exclude<\n  keyof ThemeUICSSProperties,\n  ShadowStyleKeys | 'variant'\n>\n\ntype SmartOmit<T, K extends keyof T> = Omit<T, K>\n\ntype TokenizedColorValue = MaybeTokenizedValue<'color'>\n\n// add intellisense to shadowColor -> theme.colors\ntype ReactNativeShadowStyles = SmartOmit<Shadows, 'shadowColor'> & {\n  shadowColor?: TokenizedColorValue | (string & {})\n}\n// add intellisense to textShadowColor -> theme.colors\ntype ReactNativeTextShadowStyles = SmartOmit<TextShadows, 'textShadowColor'> & {\n  textShadowColor?: TokenizedColorValue | (string & {})\n}\n\ntype ReactNativeOnlyStyles = Partial<\n  ReactNativeShadowStyles &\n    ReactNativeTextShadowStyles & {\n      transform?: ReactNativeOnlyStyles extends true\n        ? ViewStyle['transform']\n        : ViewStyle['transform'] | ThemeUICSSProperties['transform']\n    } & {\n      animationKeyframes?: Record<string, unknown>\n    }\n>\n\ntype NativeStyleProperties = ViewStyle & TextStyle & ImageStyle\n\n/**\n * If this returns `true` for a given style key,\n * then that style key must pull values from the theme.\n *\n * For example, if it's `true` for `padding`, then you must use `sx={{ padding: '$1' }}`,\n * where `$1` is the value of the theme.padding property.\n */\ntype OnlyAllowThemeValueForKey<\n  Key extends keyof ThemeUICSSProperties,\n  Scale extends\n    | keyof DripsyThemeWithoutIgnoredKeys\n    | keyof ThemeUICSSProperties = Key extends keyof Scales\n    ? // if Key = 'color'\n      // then Scales['color'] = 'colors'\n      // so if 'colors' is a keyof the theme\n      // then the scale is indeed 'colors', and we tokenize theme.colors\n      Scales[Key] extends keyof DripsyThemeWithoutIgnoredKeys\n      ? Scales[Key]\n      : Key\n    : Key,\n  AliasedScale extends Scale = AliasToScale<Scale>,\n  IsScaleInTheme extends boolean = AliasedScale extends keyof DripsyThemeWithoutIgnoredKeys\n    ? true\n    : false\n> = AliasedScale extends ScaleValue\n  ? // if we want strict types for all theme scales\n    NonNullable<\n      DripsyFinalTheme['types']\n    >['onlyAllowThemeValues'] extends 'always'\n    ? // then it is true as long as this scale exists in the theme\n      IsScaleInTheme\n    : // otherwise, check per-theme scales\n    NonNullable<\n        DripsyFinalTheme['types']\n      >['onlyAllowThemeValues'][AliasedScale] extends 'always'\n    ? // using the same logic\n      IsScaleInTheme\n    : false\n  : false\n\ntype ReactNativeTypesOnly = NonNullable<\n  DripsyFinalTheme['types']\n>['reactNativeTypesOnly'] extends true\n  ? true\n  : false\n\ntype NativeOrThemeUiStyle<\n  Key extends keyof ThemeUICSSProperties | keyof NativeStyleProperties\n> = Key extends keyof NativeStyleProperties\n  ? Key extends keyof ThemeUICSSProperties\n    ? ReactNativeTypesOnly extends true\n      ? ResponsiveValue<NativeStyleProperties[Key]>\n      : ResponsiveValue<NativeStyleProperties[Key]> | ThemeUICSSProperties[Key]\n    : ResponsiveValue<NativeStyleProperties[Key]>\n  : Key extends keyof ThemeUICSSProperties\n  ? ThemeUICSSProperties[Key]\n  : never\n\n// type NativeOrThemeUiStyle<\n//   Key extends keyof ThemeUICSSProperties | keyof NativeStyleProperties\n// > = Key extends keyof NativeStyleProperties\n//   ? Key extends keyof ThemeUICSSProperties ?\n//   ReactNativeTypesOnly extends false ? ResponsiveValue<NativeStyleProperties[Key] & {}> |  ThemeUICSSProperties[Key] & {}\n//   : ResponsiveValue<NativeStyleProperties[Key] & {}>\n//   : // otherwise, use the ThemeUI keys\n//   Key extends keyof ThemeUICSSProperties\n//   ? ThemeUICSSProperties[Key] & {} // TODO do we need {}?\n//   : never\n\ntype SxStyles = {\n  [key in StyleableSxProperties]?:\n    | (OnlyAllowThemeValueForKey<key> extends true\n        ? ResponsiveValue<MaybeTokenizedValue<key>>\n        :\n            | ResponsiveValue<MaybeTokenizedValue<key>>\n            // if this style also exists in react native keys\n            // then the type should be the native one\n            | (NativeOrThemeUiStyle<key> & {}))\n    | null\n}\n\ntype SxVariantStyles = {\n  variant?: DripsyVariant<keyof DripsyFinalTheme>\n}\n\nexport type Sx = SxStyles &\n  WebShadowStyles &\n  ReactNativeOnlyStyles &\n  SxVariantStyles\n\nexport type SxProp = Sx | ((theme: DripsyFinalTheme) => Sx)\n\ntype StringWithoutArrayKeys<T> = Exclude<Extract<T, string>, HiddenArrayKeys>\n\ntype ThemeKeysWhichContainVariants = keyof Pick<\n  DripsyThemeWithoutIgnoredKeys<DripsyFinalTheme>,\n  | 'alerts'\n  | 'badges'\n  | 'buttons'\n  | 'cards'\n  | 'forms'\n  | 'grids'\n  | 'images'\n  | 'layout'\n  | 'links'\n  | 'messages'\n  | 'shadows'\n  | 'text'\n  | 'textStyles'\n  | 'styles'\n  | 'textShadows'\n>\n\ntype TokenizeVariants<_Theme> = keyof {\n  [key in Extract<\n    keyof _Theme,\n    ThemeKeysWhichContainVariants\n  > as `${StringWithoutArrayKeys<key>}.${StringWithoutArrayKeys<\n    keyof _Theme[key]\n  >}`]: true\n}\n\nexport type UseStrictVariants<\n  Config = NonNullable<NonNullable<DripsyFinalTheme['types']>['strictVariants']>\n> = Config extends any ? (Config extends false ? false : true) : true\n\nexport type DripsyVariant<\n  ThemeKey extends keyof DripsyFinalTheme\n> = DripsyFinalTheme[ThemeKey] extends undefined\n  ? TokenizeVariants<DripsyFinalTheme>\n  : keyof DripsyFinalTheme[ThemeKey] extends undefined\n  ? TokenizeVariants<DripsyFinalTheme>\n  : UseStrictVariants extends false\n  ? TokenizeVariants<DripsyFinalTheme> | keyof DripsyFinalTheme[ThemeKey]\n  : keyof DripsyFinalTheme[ThemeKey]\n\nexport type StyledProps<ThemeKey extends keyof DripsyFinalTheme> = {\n  as?: ComponentType<any>\n  variant?: DripsyVariant<ThemeKey>\n  themeKey?: ThemeKey\n  sx?: SxProp\n  variants?: DripsyVariant<ThemeKey>[]\n}\n"]}