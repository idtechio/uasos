{"version":3,"file":"declarations.js","sourceRoot":"","sources":["../src/declarations.ts"],"names":[],"mappings":"AAiPA,MAAM,UAAU,SAAS,CACvB,KAAyB;IAEzB,OAAO,KAAK,CAAA;AACd,CAAC","sourcesContent":["import type { ViewStyle, TextStyle, ImageStyle } from 'react-native'\nimport type { Theme } from '@theme-ui/css'\nimport type { Function } from 'ts-toolbelt'\n\nexport type Shadows = Pick<\n  ViewStyle,\n  | 'elevation'\n  | 'shadowColor'\n  | 'shadowOffset'\n  | 'shadowOpacity'\n  | 'shadowRadius'\n>\n\nexport type TextShadows = Pick<\n  TextStyle,\n  'textShadowColor' | 'textShadowOffset' | 'textShadowRadius'\n>\n\ntype OnlyAllowThemeValues = 'always' | 'never'\n\ntype FontWeight =\n  | 'normal'\n  | 'bold'\n  | '100'\n  | '200'\n  | '300'\n  | '400'\n  | '500'\n  | '600'\n  | '700'\n  | '800'\n  | '900'\n  | 'normal'\n\ntype NativeStyle = ViewStyle | TextStyle | ImageStyle\n\n// this lets us use RN styles directly in theme values\n// as a result, intellisense won't break if we use things like shadows\n// and we get better intellisense in the theme itself\ntype BaseThemeWithNativeStyles = {\n  [key in keyof Theme]?: Theme[key] | { [key: string]: NativeStyle }\n}\n\nexport interface DripsyBaseTheme\n  extends Omit<BaseThemeWithNativeStyles, 'fonts' | 'shadows' | 'fontWeights'> {\n  /**\n   * Docs: https://dripsy.xyz/fonts\n   *\n   * Specify custom fonts you want to use.\n   *\n   * For context: https://github.com/nandorojo/dripsy/issues/51\n   *\n   * The key should be the name of the font you will use throughout your app. For example, `arial`.\n   *\n   * The value should be a dictionary whose keys correspond to font weights. The values should be font file names.\n   *\n   * @example\n   * ```js\n   * const theme = {\n   *   customFonts: {\n   *     arial: {\n   *       bold: 'arialBold',\n   *       '500': 'arialSemiBold',\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * A more elaborate example:\n   *\n   * ```jsx\n   * const fontName = 'arial'\n   * const theme = {\n   *   customFonts: {\n   *     [fontName]: {\n   *       bold: 'arialBold',\n   *       '400': 'arial',\n   *       default: fontName // if no font family is specified, we use this, or fallback to 400\n   *     }\n   *   },\n   *   fonts: {\n   *     root: fontName,\n   *   },\n   *   text: {\n   *     body: {\n   *       fontFamily: 'root',\n   *       fontWeight: '400'\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   *\n   */\n  customFonts?: { [key: string | number]: Record<string, string> }\n  /**\n   * Docs: https://dripsy.xyz/apis/gradient\n   *\n   * Specify linear gradients for the dripsy linear gradient package.\n   *\n   * Usage:\n   *\n   * ```tsx\n   * import { makeTheme } from 'dripsy'\n   *\n   * const theme = makeTheme({\n   *   linearGradients: { sunny: ['red', 'orange'] }\n   * })\n   *\n   * ...\n   *\n   * <Gradient gradient=\"sunny\" />\n   * ```\n   */\n  linearGradients?: {\n    [key: string]: string[]\n  }\n  fonts?: Partial<Record<'root', string>> & Partial<Record<string, string>>\n  shadows?: {\n    [key: string]: Shadows\n  }\n  textShadows?: {\n    [key: string]: TextShadows\n  }\n  fontWeights?: Partial<{\n    [key: string]: FontWeight\n  }>\n  types?: {\n    /**\n     * Docs: https://dripsy.xyz/typescript/strict\n     *\n     * This prop allows you to constrain designers to using tokens from your theme only.\n     *\n     * For existing apps, it might cause a breaking change to your types, so you might not use it. For new apps, it's probably recommended to use this.\n     *\n     * This can be set to `'always'`, `'never'`, or an object of certain theme keys which should be strict. The object approach will help for incrementally adopting this feature.\n     *\n     * Defaults to `never`\n     *\n     * If `always`, then you can only use theme values in your `sx` prop (as long as they are defined in your theme).\n     *\n     * Example:\n     *\n     * Say your `theme.space` looks like this:\n     *\n     * ```ts\n     * const theme = makeTheme({\n     *   space: {\n     *     $0: 0,\n     *     $1: 4,\n     *     $2: 8,\n     *   },\n     *   colors: {\n     *     $primary: 'cyan'\n     *   },\n     *   types: {\n     *     onlyAllowThemeValues: 'always'\n     *   }\n     * })\n     * ```\n     *\n     * Then, you will be forced to only use `$0`, `$1`, `$2` wherever you use `space` in your `sx` prop.\n     *\n     * ```tsx\n     * // ✅ this will work\n     * <View sx={{ padding: '$1', bg: '$cyan' }} />\n     *\n     *  // ❌ this will not work\n     * <View sx={{ padding: 10, bg: 'blue' }} />\n     * ```\n     *\n     * For a more incremental approach, you could structure your theme like this:\n     *\n     * ```ts\n     * const theme = makeTheme({\n     *   space: {\n     *     $0: 0,\n     *     $1: 4,\n     *     $2: 8,\n     *   },\n     *   colors: {\n     *     $primary: 'cyan'\n     *   },\n     *   types: {\n     *     onlyAllowThemeValues: {\n     *       space: 'always'\n     *     }\n     *   }\n     * })\n     * ```\n     *\n     * In this case, we are only strictly typing styles related to `space` in our `sx` prop, such as `padding`, `margin`, etc.\n     *\n     * ```tsx\n     * // ✅ this will work (color is not strict)\n     * <View sx={{ padding: '$1', color: 'blue' }} />\n     *\n     * // ❌ this will not work\n     * <View sx={{ padding: 10, color: 'blue' }} />\n     * ```\n     *\n     */\n    onlyAllowThemeValues?:\n      | OnlyAllowThemeValues\n      | {\n          [key in keyof Omit<DripsyBaseTheme, 'types'>]?: OnlyAllowThemeValues\n        }\n    /**\n     * @deprecated See the `strictVariants` option instead\n     * Defaults to `undefined | string & {}`. Set it to `undefined` to enforce that your variants match your theme.\n     */\n    variantFallbackType?: undefined | (string & {})\n    /**\n     * Docs: https://dripsy.xyz/typescript/native\n     *\n     * Defaults to `false`. If `true`, then your styles can only be React Native styles.\n     *\n     * If `false`, then the `theme-ui` styles (i.e. web styles) will also be allowed.\n     *\n     * **It is recommended to set this to `true`.** However, it is default `false` for backwards compatibility.\n     *\n     * In future versions, this may be default `true`.\n     */\n    reactNativeTypesOnly?: boolean\n    /**\n     * Default: `true`.\n     *\n     * Docs: https://dripsy.xyz/typescript/variants\n     *\n     * If `false`, then the `variant` prop of any component can accept any theme variant. If `true`, then a component can only take variants from its own theme key.\n     *\n     * For example, if `true`, then a `<Text />` component can only take variants from `theme.text`.\n     *\n     * The `themeKey` is defined by `styled()`.\n     *\n     * Recommended: `true`\n     */\n    strictVariants?: boolean\n  }\n}\n\nexport function makeTheme<T extends DripsyBaseTheme>(\n  theme: Function.Narrow<T>\n): Function.Narrow<T> {\n  return theme\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface DripsyCustomTheme {}\n\nexport interface DripsyFinalTheme\n  extends Omit<DripsyBaseTheme, keyof DripsyCustomTheme>,\n    DripsyCustomTheme {}\n\nexport type DripsyThemeWithoutIgnoredKeys<Theme = DripsyCustomTheme> = Omit<\n  Theme,\n  keyof Pick<\n    DripsyBaseTheme,\n    | 'breakpoints'\n    | 'customFonts'\n    | 'useBodyStyles'\n    | 'useLocalStorage'\n    | 'useCustomProperties'\n    | 'useColorSchemeMediaQuery'\n    | 'types'\n    | 'initialColorModeName'\n    | 'useBorderBox'\n  >\n>\n"]}